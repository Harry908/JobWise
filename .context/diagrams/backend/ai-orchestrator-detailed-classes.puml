@startuml AI Orchestrator Detailed Class Diagram
!define RECTANGLE class

title JobWise AI Orchestrator - Detailed Class Implementation

package "Domain Entities" {
    RECTANGLE MasterProfile {
        -id: UUID
        -user_id: UUID
        -personal_info: PersonalInfo
        -professional_summary: str
        -experiences: List[Experience]
        -education: List[Education]
        -skills: Skills
        -projects: List[Project]
        -version: int
        -created_at: datetime
        -updated_at: datetime
        --
        +get_relevant_experiences(keywords: List[str]): List[Experience]
        +get_technical_skills(): List[str]
        +calculate_years_experience(): float
        +to_dict(): Dict
        +validate(): ValidationResult
    }
    
    RECTANGLE JobPosting {
        -id: str
        -title: str
        -company: str
        -description: str
        -requirements: List[str]
        -salary_range: SalaryRange
        -location: str
        -remote: bool
        -job_type: JobType
        -experience_level: ExperienceLevel
        -posted_date: datetime
        --
        +extract_keywords(): List[str]
        +get_technical_requirements(): List[str]
        +get_soft_skills_requirements(): List[str]
        +estimate_match_difficulty(): float
    }
    
    RECTANGLE GeneratedDocument {
        -id: UUID
        -document_type: DocumentType
        -title: str
        -content: DocumentContent
        -metadata: DocumentMetadata
        -pdf_info: PDFInfo
        -version: int
        -created_at: datetime
        --
        +get_content(format: ContentFormat): str
        +calculate_word_count(): int
        +get_ats_keywords(): List[str]
        +generate_pdf(): bytes
    }
}

package "AI Orchestrator Core" {
    RECTANGLE AIOrchestrator {
        -execution_id: UUID
        -profile: MasterProfile
        -job: JobPosting
        -options: GenerationOptions
        -pipeline_state: PipelineState
        -token_budget: TokenBudget
        -error_handler: ErrorHandler
        -prompt_manager: PromptManager
        -llm_service: LLMService
        -stages: List[PipelineStage]
        --
        +execute_pipeline(): PipelineResult
        +get_status(): PipelineStatus
        +cancel_execution(): void
        +retry_stage(stage_number: int): StageResult
        +estimate_tokens(): TokenEstimate
        +rollback_to_stage(stage_number: int): void
        -initialize_stages(): void
        -validate_inputs(): ValidationResult
        -setup_monitoring(): void
        -cleanup_resources(): void
    }
    
    RECTANGLE PipelineState {
        -execution_id: UUID
        -current_stage: int
        -stage_results: Dict[int, StageResult]
        -start_time: datetime
        -end_time: Optional[datetime]
        -total_tokens: int
        -status: ExecutionStatus
        -error_count: int
        -retry_count: int
        --
        +advance_stage(): void
        +rollback_stage(): void
        +get_progress(): PipelineProgress
        +is_complete(): bool
        +is_failed(): bool
        +add_stage_result(stage: int, result: StageResult): void
        +get_stage_result(stage: int): Optional[StageResult]
        +calculate_eta(): Optional[datetime]
        +to_dict(): Dict
    }
    
    RECTANGLE TokenBudget {
        -total_budget: int
        -stage_allocations: Dict[str, int]
        -used_tokens: Dict[str, int]
        -reserved_tokens: int
        --
        +allocate_tokens(stage: str, amount: int): bool
        +consume_tokens(stage: str, amount: int): void
        +get_remaining(stage: str): int
        +get_total_remaining(): int
        +can_execute_stage(stage: str): bool
        +reserve_tokens(amount: int): bool
        +release_reserved(amount: int): void
        +get_usage_report(): TokenUsageReport
    }
    
    enum ExecutionStatus {
        PENDING
        INITIALIZING
        RUNNING
        COMPLETED
        FAILED
        CANCELLED
        TIMEOUT
    }
}

package "Pipeline Stage Framework" {
    abstract class PipelineStage {
        #stage_name: str
        #stage_number: int
        #max_tokens: int
        #timeout_seconds: int
        #max_retries: int
        #llm_service: LLMService
        #prompt_manager: PromptManager
        #metrics_collector: MetricsCollector
        --
        +{abstract} execute(input: StageInput): StageResult
        +{abstract} validate_input(input: StageInput): ValidationResult
        #prepare_execution(input: StageInput): ExecutionContext
        #log_metrics(result: StageResult): void
        #handle_timeout(): StageResult
        #create_error_result(error: Exception): StageResult
        #estimate_tokens(input: StageInput): int
    }
    
    RECTANGLE StageInput {
        -stage_number: int
        -execution_id: UUID
        -data: Dict[str, Any]
        -previous_results: List[StageResult]
        -context: ExecutionContext
        --
        +get_data[T](key: str, type_: Type[T]): T
        +has_data(key: str): bool
        +get_previous_result(stage: int): Optional[StageResult]
        +add_context(key: str, value: Any): void
        +validate_required_keys(keys: List[str]): ValidationResult
    }
    
    RECTANGLE StageResult {
        -stage_number: int
        -stage_name: str
        -status: StageStatus
        -output_data: Dict[str, Any]
        -tokens_used: int
        -execution_time: float
        -start_time: datetime
        -end_time: datetime
        -error_message: Optional[str]
        -metrics: Dict[str, Any]
        -retry_count: int
        --
        +is_success(): bool
        +is_failure(): bool
        +needs_retry(): bool
        +get_output[T](key: str, type_: Type[T]): T
        +add_output(key: str, value: Any): void
        +add_metric(name: str, value: Any): void
        +get_duration(): float
        +to_dict(): Dict
    }
    
    enum StageStatus {
        SUCCESS
        FAILURE
        RETRY_NEEDED
        TIMEOUT
        CANCELLED
        VALIDATION_ERROR
    }
}

package "Stage 1: Job Analyzer" {
    RECTANGLE JobAnalyzer {
        -keywords_extractor: KeywordExtractor
        -requirements_parser: RequirementsParser
        -seniority_assessor: SeniorityAssessor
        -ats_analyzer: ATSAnalyzer
        --
        +execute(input: JobAnalysisInput): JobAnalysisResult
        +validate_input(input: JobAnalysisInput): ValidationResult
        -extract_ats_keywords(description: str): List[ATSKeyword]
        -parse_requirements(description: str): List[Requirement]
        -categorize_skills(requirements: List[str]): SkillCategories
        -assess_seniority_level(description: str): SeniorityLevel
        -analyze_company_culture(description: str): CompanyCulture
        -estimate_competition_level(): CompetitionLevel
    }
    
    RECTANGLE JobAnalysisInput {
        -job_posting: JobPosting
        -analysis_depth: AnalysisDepth
        -focus_areas: List[str]
        --
        +get_job_description(): str
        +get_company_info(): CompanyInfo
        +should_analyze_salary(): bool
    }
    
    RECTANGLE JobAnalysisResult {
        -required_keywords: List[ATSKeyword]
        -preferred_keywords: List[ATSKeyword]
        -technical_requirements: List[TechnicalRequirement]
        -soft_skills: List[SoftSkill]
        -experience_requirements: ExperienceRequirements
        -education_requirements: EducationRequirements
        -seniority_level: SeniorityLevel
        -company_culture: CompanyCulture
        -ats_friendliness: float
        -competition_score: float
        --
        +get_all_keywords(): List[ATSKeyword]
        +get_priority_requirements(): List[Requirement]
        +get_nice_to_have(): List[str]
        +calculate_complexity_score(): float
    }
    
    RECTANGLE ATSKeyword {
        -keyword: str
        -category: KeywordCategory
        -importance: ImportanceLevel
        -frequency: int
        -variations: List[str]
        --
        +get_weight(): float
        +matches(text: str): bool
        +get_all_forms(): List[str]
    }
    
    enum KeywordCategory {
        TECHNICAL_SKILL
        SOFT_SKILL
        TOOL_TECHNOLOGY
        CERTIFICATION
        INDUSTRY_TERM
        JOB_FUNCTION
    }
    
    enum ImportanceLevel {
        CRITICAL
        HIGH
        MEDIUM
        LOW
        NICE_TO_HAVE
    }
}

package "Stage 2: Profile Compiler" {
    RECTANGLE ProfileCompiler {
        -relevance_scorer: RelevanceScorer
        -content_ranker: ContentRanker
        -match_calculator: MatchCalculator
        -skill_mapper: SkillMapper
        --
        +execute(input: ProfileCompilationInput): ProfileCompilationResult
        +validate_input(input: ProfileCompilationInput): ValidationResult
        -score_experiences(experiences: List[Experience], job_reqs: List[Requirement]): List[ScoredExperience]
        -rank_skills(skills: List[str], keywords: List[ATSKeyword]): List[RankedSkill]
        -select_education(education: List[Education], job_reqs: EducationRequirements): List[Education]
        -calculate_overall_match(): MatchScore
        -identify_gaps(): List[SkillGap]
        -generate_emphasis_plan(): EmphasisPlan
    }
    
    RECTANGLE ProfileCompilationInput {
        -profile: MasterProfile
        -job_analysis: JobAnalysisResult
        -compilation_strategy: CompilationStrategy
        --
        +get_target_keywords(): List[ATSKeyword]
        +get_scoring_weights(): ScoringWeights
        +should_include_projects(): bool
    }
    
    RECTANGLE ProfileCompilationResult {
        -scored_experiences: List[ScoredExperience]
        -ranked_skills: List[RankedSkill]
        -selected_education: List[Education]
        -selected_projects: List[Project]
        -match_score: MatchScore
        -skill_gaps: List[SkillGap]
        -emphasis_recommendations: List[EmphasisRecommendation]
        -content_priority_map: Dict[str, float]
        --
        +get_top_experiences(n: int): List[ScoredExperience]
        +get_relevant_skills(threshold: float): List[RankedSkill]
        +get_match_percentage(): float
        +get_improvement_suggestions(): List[str]
    }
    
    RECTANGLE ScoredExperience {
        -experience: Experience
        -relevance_score: float
        -keyword_matches: List[KeywordMatch]
        -achievement_scores: List[float]
        -recency_bonus: float
        -total_score: float
        --
        +get_weighted_score(): float
        +get_best_achievements(n: int): List[str]
        +has_keyword_match(keyword: str): bool
        +calculate_impact_score(): float
    }
    
    RECTANGLE RankedSkill {
        -skill: str
        -category: SkillCategory
        -relevance_score: float
        -keyword_match: Optional[ATSKeyword]
        -proficiency_level: ProficiencyLevel
        -verification_source: VerificationSource
        --
        +get_display_priority(): int
        +should_emphasize(): bool
        +get_context_examples(): List[str]
    }
    
    RECTANGLE MatchScore {
        -overall_percentage: float
        -technical_match: float
        -experience_match: float
        -education_match: float
        -soft_skills_match: float
        -breakdown: Dict[str, float]
        --
        +get_strongest_areas(): List[str]
        +get_weak_areas(): List[str]
        +is_strong_match(): bool
        +get_confidence_level(): float
    }
}

package "Stage 3: Document Generator" {
    RECTANGLE DocumentGenerator {
        -template_engine: TemplateEngine
        -content_optimizer: ContentOptimizer
        -bullet_formatter: BulletPointFormatter
        -section_organizer: SectionOrganizer
        --
        +execute(input: DocumentGenerationInput): DocumentGenerationResult
        +validate_input(input: DocumentGenerationInput): ValidationResult
        -generate_professional_summary(profile: MasterProfile, emphasis: EmphasisPlan): str
        -format_experience_section(experiences: List[ScoredExperience]): str
        -optimize_bullet_points(achievements: List[str], keywords: List[ATSKeyword]): List[str]
        -generate_skills_section(skills: List[RankedSkill]): str
        -apply_template_formatting(content: Dict[str, str], template: Template): str
        -ensure_ats_compliance(content: str): str
    }
    
    RECTANGLE DocumentGenerationInput {
        -compilation_result: ProfileCompilationResult
        -job_analysis: JobAnalysisResult
        -generation_options: GenerationOptions
        -template: Template
        --
        +get_content_strategy(): ContentStrategy
        +get_length_constraints(): LengthConstraints
        +should_include_cover_letter(): bool
    }
    
    RECTANGLE DocumentGenerationResult {
        -resume_content: ResumeContent
        -cover_letter_content: Optional[CoverLetterContent]
        -formatting_metadata: FormattingMetadata
        -content_statistics: ContentStatistics
        -keyword_density: Dict[str, float]
        -readability_score: float
        --
        +get_content(doc_type: DocumentType, format: ContentFormat): str
        +get_word_count(section: str): int
        +get_keyword_coverage(): float
        +validate_content(): List[ContentIssue]
    }
    
    RECTANGLE ResumeContent {
        -header: HeaderSection
        -professional_summary: str
        -experience_section: str
        -education_section: str
        -skills_section: str
        -projects_section: Optional[str]
        -certifications_section: Optional[str]
        --
        +to_text(): str
        +to_html(): str
        +to_markdown(): str
        +get_section_word_counts(): Dict[str, int]
    }
    
    RECTANGLE CoverLetterContent {
        -opening_paragraph: str
        -body_paragraphs: List[str]
        -closing_paragraph: str
        -call_to_action: str
        --
        +to_full_letter(): str
        +get_tone_analysis(): ToneAnalysis
        +validate_structure(): bool
    }
}

package "Stage 4: Quality Validator" {
    RECTANGLE QualityValidator {
        -ats_checker: ATSComplianceChecker
        -factuality_validator: FactualityValidator
        -grammar_checker: GrammarChecker
        -keyword_analyzer: KeywordAnalyzer
        -format_validator: FormatValidator
        --
        +execute(input: ValidationInput): ValidationResult
        +validate_input(input: ValidationInput): ValidationResult
        -check_ats_compliance(content: str, keywords: List[ATSKeyword]): ATSComplianceResult
        -validate_factuality(content: str, profile: MasterProfile): FactualityResult
        -check_grammar_quality(content: str): GrammarResult
        -verify_keyword_coverage(content: str, keywords: List[ATSKeyword]): KeywordCoverageResult
        -validate_format_consistency(content: str): FormatResult
        -calculate_overall_quality(): QualityScore
    }
    
    RECTANGLE ValidationInput {
        -generated_content: DocumentGenerationResult
        -original_profile: MasterProfile
        -job_analysis: JobAnalysisResult
        -quality_thresholds: QualityThresholds
        --
        +get_content_to_validate(): str
        +get_expected_keywords(): List[ATSKeyword]
        +get_factual_references(): List[FactualClaim]
    }
    
    RECTANGLE ValidationResult {
        -overall_quality: QualityScore
        -ats_compliance: ATSComplianceResult
        -factuality_check: FactualityResult
        -grammar_check: GrammarResult
        -keyword_coverage: KeywordCoverageResult
        -format_validation: FormatResult
        -recommendations: List[QualityRecommendation]
        -needs_regeneration: bool
        -critical_issues: List[CriticalIssue]
        --
        +is_acceptable_quality(): bool
        +get_improvement_suggestions(): List[str]
        +get_regeneration_feedback(): RegenerationFeedback
        +calculate_confidence_score(): float
    }
    
    RECTANGLE ATSComplianceResult {
        -compliance_score: float
        -keyword_optimization: float
        -format_score: float
        -readability_score: float
        -section_completeness: float
        -issues: List[ATSIssue]
        --
        +passes_ats_threshold(): bool
        +get_optimization_suggestions(): List[str]
        +get_critical_fixes(): List[str]
    }
    
    RECTANGLE FactualityResult {
        -accuracy_score: float
        -verified_claims: List[VerifiedClaim]
        -unverifiable_claims: List[UnverifiableClaim]
        -contradictions: List[Contradiction]
        -exaggerations: List[Exaggeration]
        --
        +has_factual_issues(): bool
        +get_correction_suggestions(): List[str]
        +requires_manual_review(): bool
    }
}

package "Stage 5: PDF Exporter" {
    RECTANGLE PDFExporter {
        -pdf_generator: PDFGenerator
        -template_selector: TemplateSelector
        -layout_optimizer: LayoutOptimizer
        -metadata_injector: MetadataInjector
        --
        +execute(input: PDFExportInput): PDFExportResult
        +validate_input(input: PDFExportInput): ValidationResult
        -select_optimal_template(preferences: UserPreferences, content: str): PDFTemplate
        -generate_pdf_document(content: str, template: PDFTemplate): bytes
        -optimize_layout(content: str, constraints: LayoutConstraints): LayoutResult
        -add_metadata(pdf_bytes: bytes, metadata: DocumentMetadata): bytes
        -validate_pdf_quality(pdf_bytes: bytes): PDFQualityResult
    }
    
    RECTANGLE PDFExportInput {
        -validated_content: ValidationResult
        -template_preferences: TemplatePreferences
        -layout_constraints: LayoutConstraints
        -metadata: DocumentMetadata
        --
        +get_content(): str
        +get_preferred_template(): str
        +should_optimize_layout(): bool
    }
    
    RECTANGLE PDFExportResult {
        -pdf_bytes: bytes
        -pdf_metadata: PDFMetadata
        -file_info: FileInfo
        -quality_metrics: PDFQualityMetrics
        -storage_url: Optional[str]
        --
        +save_to_storage(storage: StorageService): str
        +get_download_url(): str
        +validate_integrity(): bool
        +get_file_size(): int
    }
    
    RECTANGLE PDFMetadata {
        -title: str
        -author: str
        -subject: str
        -creator: str
        -producer: str
        -creation_date: datetime
        -keywords: List[str]
        --
        +to_pdf_info(): Dict[str, str]
        +add_custom_property(key: str, value: str): void
    }
}

package "Supporting Services" {
    RECTANGLE LLMService {
        -client: OpenAIClient
        -token_manager: TokenManager
        -rate_limiter: RateLimiter
        -retry_handler: RetryHandler
        -response_parser: ResponseParser
        --
        +generate_completion(prompt: str, model: str, max_tokens: int): LLMResponse
        +estimate_tokens(text: str): int
        +check_rate_limits(): RateLimitStatus
        +get_model_info(model: str): ModelInfo
        -handle_rate_limit(): void
        -validate_response(response: str): ValidationResult
    }
    
    RECTANGLE PromptManager {
        -template_store: PromptTemplateStore
        -version_manager: VersionManager
        -variable_resolver: VariableResolver
        --
        +get_prompt(stage: str, version: str): PromptTemplate
        +render_prompt(template: PromptTemplate, context: Dict): str
        +validate_prompt(prompt: str): ValidationResult
        +get_token_estimate(template: PromptTemplate, context: Dict): int
        -load_template(template_id: str): PromptTemplate
        -resolve_variables(template: str, context: Dict): str
    }
    
    RECTANGLE ErrorHandler {
        -retry_strategies: Dict[Exception, RetryStrategy]
        -fallback_handlers: Dict[str, FallbackHandler]
        -circuit_breaker: CircuitBreaker
        -error_logger: ErrorLogger
        --
        +handle_error(error: Exception, context: ErrorContext): ErrorHandleResult
        +should_retry(error: Exception, attempt: int): bool
        +get_fallback(error_type: str): Optional[FallbackHandler]
        +log_error(error: Exception, context: ErrorContext): void
        -classify_error(error: Exception): ErrorCategory
        -get_retry_delay(attempt: int): float
    }
    
    RECTANGLE MetricsCollector {
        -stage_metrics: Dict[str, StageMetrics]
        -performance_tracker: PerformanceTracker
        -token_tracker: TokenTracker
        --
        +record_stage_start(stage: str, context: Dict): void
        +record_stage_end(stage: str, result: StageResult): void
        +record_token_usage(stage: str, tokens: int): void
        +get_performance_summary(): PerformanceSummary
        +export_metrics(): Dict[str, Any]
    }
}

' Inheritance relationships
PipelineStage <|-- JobAnalyzer
PipelineStage <|-- ProfileCompiler
PipelineStage <|-- DocumentGenerator
PipelineStage <|-- QualityValidator
PipelineStage <|-- PDFExporter

' Composition relationships
AIOrchestrator *-- PipelineState
AIOrchestrator *-- TokenBudget
AIOrchestrator *-- ErrorHandler
AIOrchestrator *-- PromptManager
AIOrchestrator *-- LLMService
AIOrchestrator *-- MetricsCollector

PipelineState *-- StageResult
TokenBudget --> AIOrchestrator

' Stage input/output relationships
JobAnalyzer ..> JobAnalysisResult : creates
ProfileCompiler ..> ProfileCompilationResult : creates
DocumentGenerator ..> DocumentGenerationResult : creates
QualityValidator ..> ValidationResult : creates
PDFExporter ..> PDFExportResult : creates

' Dependencies
JobAnalyzer --> LLMService
JobAnalyzer --> PromptManager
ProfileCompiler --> LLMService
ProfileCompiler --> PromptManager
DocumentGenerator --> LLMService
DocumentGenerator --> PromptManager
QualityValidator --> LLMService
QualityValidator --> PromptManager

' Entity usage
JobAnalyzer --> JobPosting
ProfileCompiler --> MasterProfile
DocumentGenerator --> MasterProfile
QualityValidator --> MasterProfile
PDFExporter --> GeneratedDocument

note top of AIOrchestrator
Central orchestrator managing the entire
5-stage AI generation pipeline with:
- Token budget management (8000 total)
- Error handling and recovery
- Progress tracking and status updates
- Rollback and retry capabilities
end note

note bottom of LLMService
Service abstraction for LLM providers:
- OpenAI GPT-3.5/4 integration
- Rate limiting and retry logic
- Token estimation and management
- Response validation and parsing
end note

note right of ValidationResult
Quality validation ensures:
- ATS compliance (>85% target)
- Factual accuracy vs. profile
- Grammar and readability
- Keyword coverage (>90%)
- Format consistency
end note

@enduml